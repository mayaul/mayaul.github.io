---
layout: post
title: "feign 좀더 나아가기"
excerpt: "이전 feign 게시글에서 좀더 상세하게 "
date: 2019-12-12 00:00:00 +0900
comments: true
tag:
- feign
---
### 소개
<hr/>

* 이 글은 이전에 작성된 게시글에서 추가 보완사항에 대해서 작성되었습니다.[feign](https://mayaul.github.io/feign)
* 예제소스 [링크](https://github.com/mayaul/feign-apply-experience-2nd-sample)

### http client
* feign 에서 지원하는 http client 는 ApacheHttpClient 와 OkHttpClient 가 있습니다.  default 는 ApacheHttpClient 입니다.
    - HttpClientFeignLoadBalancedConfiguration 와 OkHttpFeignLoadBalancedConfiguration 을 볼면 알 수 있는데, `@ConditionalOnProperty(value = "feign.httpclient.enabled", matchIfMissing = true)` 로 설정되어 있습니다.
    - 아래 내용을 의존성에 넣어보면 확인 할 수 있습니다.
        ``` gradle
        compile group: 'io.github.openfeign', name: 'feign-httpclient', version: '9.5.1' 넣어보면, 디버깅으로 확인 할 수 있습니다.
        ```
* OkHttpClient 의 장점에 대해서는 링크를 통해서 확인 할 수 있습니다.[OkHttpClient 가 ApacheHttpClient 비해 장단점](https://github.com/square/okhttp/issues/3472)
    ```* [Feign](https://github.com/Netflix/feign) 은  Netflix 에서 개발된 Http client binder 입니다.
* Feign 을 사용하면 웹 서비스 클라이언트를 보다 쉽게 작성할 수 있습니다.
* Feign 을 사용하기 위해서는 interface 를 작성하고 annotation 을 선언 하기만 하면됩니다.
    - 마치 Spring Data JPA 에서 실제 쿼리를 작성하지 않고 Interface 만 지정하여 쿼리실행 구현체를 자동으로 만들어주는 것과 유사합니다.
* 설명보다는 소스코드를 한번 보고, RestTemplate 을 만들어 보셨던 분들은 많은 코드의 축소를 느끼게 되실겁니다.<br/>
(잘 모르겠다 하시면, 동일한 호출을 RestTemplate 으로 만들어서 보시면 아시게 될거라 생각합니다.)

### 예제 소스 코드
<hr/>

* [예제코드](https://github.com/woowabros/feign-apply-experience-sample)
    - 우선 예제코드를 git clone 하신다음에 아래 설명과 같이 예제코드를 사용을 권장드립니다.
    - 모든 예제코드는 test code 가 있습니다. spock 으로 작성이 되어있으나, 테스트 코드만 run 해보시면서 설명을 봐주세요.
        + spock 테스트 코드가 익숙하지 않다면, controller 를 만드신다음에 테스트 해보셔도 됩니다.

### 의존성
<hr/>

* 기본적으로 필요한 의존성이 있습니다. 아래 의존성은 feign 을 사용하기 위한 최소의 의존성이고, 예제 프로젝트를 보시게 되면 아래 의존성보다는 좀더 많은 의존성이 있습니다.
    ```java
    ext {
        ...   
        // https://spring.io/projects/spring-cloud 의 Release Trains 부분을 보세요.
        springCloudVersion = 'Finchley.RELEASE'
        ...
     
    }
     
    dependencyManagement {
        imports {
            mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
        }
    }
     
    dependencies {
        compile("org.springframework.cloud:spring-cloud-starter-openfeign")
    }
    ```

    * springCloudVersion 의 경우 spring boot 버전에 맞는 버전을 사용을 하셔야 합니다.
    * 주석에 있는 링크로 이동하셔서 사용하시는 spring boot 버전에 맞는 버전을 사용해주세요.

### Feign 사용하기
<hr/>

```java
@SpringBootApplication
@EnableFeignClients
public class Application {
 
    public static void main(String... args) {
        SpringApplication.run(Application.class, args);
    }
}
```
```java
@FeignClient(value = "example", url = "${external-api.http-bin}")
public interface ExampleClient {
 
    @GetMapping("/status/{status}")
    void status(@PathVariable("status") int status);
}
```
1. @EnableFeignClients 을 사용하셔야합니다.<br/>
root package 에 있어야 하며, 그렇지 않은 경우 `basePackages` 또는 `basePackageClasses` 를 지정해주셔야 합니다.
2. @EnableFeignClients 은 지정된 package 를 돌아다니면서 @FeignClient 를 찾아 구현체를 만들어 줍니다.

* 혹시 수동으로 구현체를 만들고 싶다면 아래 링크를 참고해주세요.<br/>
[수동으로 feign 구현체 만들기](https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-feign.html#_creating_feign_clients_manually)

### 기본설정 값 및 override
<hr/>

* feign 를 하다보면, 기본으로 설정되는 bean 들이 있습니다.
* Spring 을 사용하는 환경이라면, org.springframework.cloud.openfeign.FeignClientsConfiguration 에서 어떤 Bean 이 만들어지는지 보면 됩니다.
* default 설정을 override 하고 싶다면, configuration 에 설정된 값을 넣으면 됩니다.
    ```java
    
    @FeignClient(value = "example", url = "https://httpbin.org", configuration = {FeignConfiguration.class})
    public interface ExampleClient {
    
        @GetMapping("/status/{status}")
        void status(@PathVariable("status") int status);
    }
    ```

### Request 요청
<hr/>

#### Header 에 값 설정하기
* Request Header 에 값을 넣는 방식은 몇가지가 있습니다. 이중에 목적에 맞는 방법을 선택을 하셔서 사용하시면 됩니다.
* 저희팀에서는 주로 Configuration 을 이용해서 넣는 방법으로 합니다.<br/>
이유는 method 별로 별도의 header 를 설정을 하는것이 아닌, feign client 별로 설정이 필요해서 였습니다.

    - 방법 1
        ```java
        public class HeaderConfiguration {
            @Bean
            public RequestInterceptor requestInterceptor() {
                return requestTemplate -> requestTemplate.header("header", "header1", "header2");
            }
        }
        ```
        ```java
        @FeignClient(value = "step2", url = "https://httpbin.org", configuration = {HeaderConfiguration.class})
        public interface Step2Client {
            ...
        }
        ```
        + configuration 을 이용해서 설정하기
            + Header 값을 설정할 configuration class 를 생성을 하고, RequestInterceptor 을 생성해줍니다.
            + 이제는 원하는 feign client 에 configuration 에 만든 class 를 설정해주면 됩니다.

    - 방법2
        ```java
        
        @GetMapping(value = "/status/{status}", headers = "key2=value2")
        void status2(@PathVariable("status") int status);
        
        @GetMapping(value = "/status/{status}")
        void status3(@RequestHeader("key3") String headers, @PathVariable("status") int status);
        
        // 이 호출은 Header 에 값이 설정되지 않습니다.
        // @GetMapping 은 SpringMVcContract 를 사용해야하고, @Headers 는 feign Contract 를 사용해야 합니다.
        @org.springframework.web.bind.annotation.GetMapping(value = "/status/{status}")
        @feign.Headers("key3: value3")
        void status4(@PathVariable("status") int status);
        ```
        + annotation 이용하기
            + 3가지 방법모두 잘 되는데요, 단 3번째 방법의 경우 Contract 를 feign 에서 제공해준 Default Contract 를 사용해야합니다.
            + Contract 의 경우 feign client 구현체를 만들때 기반이 되는 내용인데요.<br/>
            spring 에서 제공한 Contract 와 feign 에서 사용하는 Contract 가 있습니다. Spring 에서 제공한 Contract 를 사용하면,
            spring 을 사용했던 경험으로 인해 feign client 를 보다 쉽게 만들 수 있습니다.

#### BasicAuth 인증하기

* 이것도 방법은 여러개 있을지 모르겠지만, 제가 선택한건 Configuration 을 이용한 방법입니다.
    ```java
    public class BasicAuthConfiguration {
    
        @Bean
        public BasicAuthRequestInterceptor basicAuthRequestInterceptor() {
            return new BasicAuthRequestInterceptor("mayaul", "1234567890");
        }
    }
    ```

### 하기 쉬운 실수
<hr/>

* feign.Contract.Default 를 사용하는 실수
    - 위에서 말씀드렸듯이 Contract 는 2가지가 있습니다.
    - org.springframework.cloud:spring-cloud-starter-openfeign 을 사용하게 되면 SpringMvcContract 를 사용하게 되어 @GetMapping, @PostMapping, @RequestMapping 을 사용할 수 있습니다.
    - Feign 에서 제공하는 Default 를 사용하게 되면, 위에 있는 것이 아닌 feign.RequestLine 을 사용해야 합니다.
    - Feign 에서 제공하는 Default Contract 를 사용하는데 @GetMapping 과 같은 것을 사용한다면 아래와 같은 오류를 보게 됩니다.
        ```java
        Caused by: java.lang.IllegalStateException: Method status not annotated with HTTP method type (ex. GET, POST)
        at feign.Util.checkState(Util.java:128)
        at feign.Contract$BaseContract.parseAndValidateMetadata(Contract.java:99)
        at feign.Contract$BaseContract.parseAndValidatateMetadata(Contract.java:66)
        at feign.ReflectiveFeign$ParseHandlersByName.apply(ReflectiveFeign.java:146)
        at feign.ReflectiveFeign.newInstance(ReflectiveFeign.java:53)
        at feign.Feign$Builder.target(Feign.java:218)
        at org.springframework.cloud.openfeign.HystrixTargeter.target(HystrixTargeter.java:39)
        at org.springframework.cloud.openfeign.FeignClientFactoryBean.getObject(FeignClientFactoryBean.java:261)
        at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:171)
        ... 28 more
        ```

* feign logger level 을 full 로 설정했는데 로그 출력이 되지 않음
    - [feign logger level](https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-feign.html#_feign_logging) 을 보면, request 와 response 의 header, body 등의 상세한 로그가 나와야 합니다.
    - FULL 로 설정을 했음에도 나오지가 않는다면, @FeignClient 으로 client 를 만든 package log level 을 DEBUG 로 설정했는지 확인해보세요.
    - FULL 로 설정하면 볼 수 있는 로그
        ```
        [Class#method] ---> GET https://httpbin.org/status/200 HTTP/1.1
        [Class#method] ---> END HTTP (0-byte body)
        [Class#method] <--- HTTP/1.1 200 OK (1437ms)
        [Class#method] access-control-allow-credentials: true
        [Class#method] access-control-allow-origin: *
        [Class#method] connection: keep-alive
        [Class#method] content-length: 0
        [Class#method] content-type: text/html; charset=utf-8
        [Class#method] date: Mon, 13 May 2019 12:15:41 GMT
        [Class#method] referrer-policy: no-referrer-when-downgrade
        [Class#method] server: nginx
        [Class#method] x-content-type-options: nosniff
        [Class#method] x-frame-options: DENY
        [Class#method] x-xss-protection: 1; mode=block
        [Class#method] 
        [Class#method] <--- END HTTP (0-byte body)
        ```

* PathVariable 에 값이 들어가지 않음
    - Spring MVC Controller 에서는 @PathVariable, @QueryParam 에 value(name) 을 넣지 않아도, field 의 이름이 default 로 설정되어 유입된 값이 셋팅이 되지만, feign 에서는 value(name) 값을 넣어줘야 @GetMapping @PostMapping 등에 있는 url 에 자동으로 넣어줍니다.
    - default 로 넣어줄거라 생각하고 안넣어주면 에러가 발생됩니다.

* Feign client method parameter 에 @PathVariable, @QueryParam, @RequestBody 와 같은 annotation 을 설정하지 않음
    - 아무것도 설정하지 않으면 @RequestBody 로 생각해서 Http Body 로 데이터를 보낼려고 합니다.
    - 이 때, parameter 가 2개 이상이 되면 `Method has too many Body parameters` 이라는 에러가 발생됩니다.
        ```java
        @PostMapping(value = "/anything")
        void anything(ExampleRequest request, ExampleRequest request2);
        ```
* feign client 용 configuration class 에 @Configuration annotation 하면 안됨
    - feign client interface 에 사용할 목적을 가지고 configuration class 를 만든것에 @Configuration 을 사용을 하게 되면, 초반에 Bean 생성을 할 때, 이 configuration class 에 있는 Bean 도 Bean 을 만들어 버려서 모든 feign client 에 적용이 됩니다.
    - 습관적으로 configuration 이라서 @Configuration 을 설정하신다면, 의도하지 않은 설정이 되게 됩니다.

### Java8 이상 에서 필수 설정
<hr/>

* Get 에서 RequestParam 으로 LocalTime 을 보낼 때
    - 기본 설정을 그대로 사용을 할 경우 urlEncode를 한 값으로 보내는 것 같다. (여튼 잘 보내지지 않아요~)
    - 이 bean 설정을 넣고, feign client 에서 이 bean 이 설정된 configuration 을 사용을 하면, ISO Format 을 이용해서 보내게 됩니다.
        ```java
        @Bean
        public FeignFormatterRegistrar localDateFeignFormatterRegister() {
            return registry -> {
                DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
                registrar.setUseIsoFormat(true);
                registrar.registerFormatters(registry);
            };
        }
        ```

* Request Body, Response Body 에 LocalDate, LocalTime, LocalDateTime 이 있을 때
    - feign 에서 도 ObjectMapper 를 이용해서 Json 을 Serialize, Deserialize 를 합니다
    - 이 ObjectMapper 에 LocalDate, LocalTime, LocalDateTime 에 대한 설정이 들어가 있어야 합니다
    - Spring Boot 2.0 을 하고 있고 web-starter 를 의존성이 있다면, 이 의존성에 아래 2가지도 의존성에 있습니다.
(저희 같은 경우에는 모든 프로젝트가 의존성을 가지고 있는 common module 에 넣었습니다.다만, Spring Batch 에는 없으니, Spring Batch 에서 feign client 를 호출을 할 필요가 있다면 위 2가지 의존성을 넣어줘야 합니다.
        ```java
        compile('com.fasterxml.jackson.datatype:jackson-datatype-jdk8')
        compile('com.fasterxml.jackson.datatype:jackson-datatype-jsr310')
        ```

### 좀더 나아가기
<hr/>

* error decode
    - ErrorDecoder 를 추가를 하고, 이 ErrorDecoder 를 사용하는 부분은 `feign.SynchronousMethodHandler#executeAndDecode` 여기에 있습니다
    - 기본 로직은
        + 일단 http status code 가 200에서 300 사이면, 설정된 decoder 를 실행합니다.
        + 그 이외 decode404 를 true 로 설정(기본값은 false), http status code 가 404 이면서 return type 이 void class 이어도 decoder 를 실행하게 됩니다.<br/>
        이 건 404 를 에러가 아닌 정상적인 값으로 판단하고 싶을때 사용하는 기능인것으로 보이네요.
        + 이 2개의 선행 조건문을 만족하지 않으면 errorDecoder 를 수행하게 됩니다.
            ```java
            if (void.class == metadata.returnType()) {
                return null;
              } else {
                return decode(response);
              }
            } else if (decode404 && response.status() == 404 && void.class != metadata.returnType()) {
              return decode(response);
            } else {
              throw errorDecoder.decode(metadata.configKey(), response);
            }
            ```
* retryer
    - ribbon 을 이용하여, retry 를 할 수 있지만, feign 자체에서도 retryer 를 설정하여 retry 를 할 수 있습니다.
    - feign.SynchronousMethodHandler#invoke 에서 feign.RetryableException 을 throw 해야 retryer 가 작동합니다.
    - 기본 동작은,
        + connection 을 가지고 오지 못했다거나, httpstatus code 가 0 이하인 invalid 한 status code 값이어야 RetryableException 이 발생됩니다.
        + http status code 에 따라서, Retry 를 하고 싶은경우 별도의 ErrorDecode 를 만들어 거기서 httpStatus code 에 따라서 RetryableException 을 throw 해주면 됩니다.
        + Default Retryer 는 100ms 를 시작으로 1.5 곱하면서 재시도를 하고, 최대 5번 합니다.
            * RetryableException 에 retryAfter를 설정하면, 1초뒤에 재시도 할 수 있습니다.
            * 기본생성자가 아닌, 다른 생성자를 사용하면 retry 설정 할 수 있습니다.
                ```java
                public Default() {
                  this(100, SECONDS.toMillis(1), 5);
                }
            
                public Default(long period, long maxPeriod, int maxAttempts) {
                  this.period = period;
                  this.maxPeriod = maxPeriod;
                  this.maxAttempts = maxAttempts;
                  this.attempt = 1;
                }
                ```
* 예를 들어, ErrorDecoder 와 Retry 를 조합해서, 5xx 에러가 발생을 했을때 재시도를 하고 싶을때는 아래와 같이 하시면 됩니다.<br/>
    예제코드 `io.github.mayaul.feign.tip.RetryClient` 를 보시면 될 것 같습니다.
    > 재시도는 1초를 시작으로 최대 2초로 재시도 하고, 최대 3번으로 재시도 하도록 설정했습니다.<br/>
    > 최초 1초이고, 그 이후는 1.5를 곱하면서 재시도를 합니다.
    - 2개의 설정을 override 를 해야합니다.
        ```java
        public class FeignRetryConfiguration {
            @Bean
            public Retryer retryer() {
                return new Retryer.Default(1000, 2000, 3);
            }
        
            @Bean
            public ErrorDecoder decoder() {
                return (methodKey, response) -> {
                    if (HttpStatusClass.SERVER_ERROR.contains(response.status())) {
        
                        return new RetryableException(format("%s 요청이 성공하지 못했습니다. Retry 합니다. - status: %s, headers: %s", methodKey, response.status(), response.headers()), null);
                    }
        
                    return new IllegalStateException(format("%s 요청이 성공하지 못했습니다. - status: %s, headers: %s", methodKey, response.status(), response.headers()));
                };
            }
        }
        ```
        ```java
        @FeignClient(value = "retry", url = "${external-api.http-bin}", configuration = {FeignRetryConfiguration.class})
        public interface RetryClient {
        
            @GetMapping("/status/{status}")
            void status(@PathVariable("status") int status);
        }
        ```
        + 코드를 실행하면 결과는
           ```java
            2019-05-30 12:18:22.005 [RetryClient#status] ---> GET https://httpbin.org/status/500 HTTP/1.1
            2019-05-30 12:18:22.005 [RetryClient#status] ---> END HTTP (0-byte body)
            2019-05-30 12:18:23.138 [RetryClient#status] <--- HTTP/1.1 500 INTERNAL SERVER ERROR (1132ms)
            2019-05-30 12:18:23.140 [RetryClient#status] <--- END HTTP (0-byte body)
            2019-05-30 12:18:24.676 [RetryClient#status] ---> RETRYING
            2019-05-30 12:18:24.676 [RetryClient#status] ---> GET https://httpbin.org/status/500 HTTP/1.1
            2019-05-30 12:18:24.676 [RetryClient#status] ---> END HTTP (0-byte body)
            2019-05-30 12:18:24.889 [RetryClient#status] <--- HTTP/1.1 500 INTERNAL SERVER ERROR (212ms)
            2019-05-30 12:18:24.891 [RetryClient#status] <--- END HTTP (0-byte body)
            2019-05-30 12:18:26.892 [RetryClient#status] ---> RETRYING
            2019-05-30 12:18:26.892 [RetryClient#status] ---> GET https://httpbin.org/status/500 HTTP/1.1
            2019-05-30 12:18:26.892 [RetryClient#status] ---> END HTTP (0-byte body)
            2019-05-30 12:18:27.108 [RetryClient#status] <--- HTTP/1.1 500 INTERNAL SERVER ERROR (215ms)
            2019-05-30 12:18:27.109 [RetryClient#status] <--- END HTTP (0-byte body)
            ```
        + 1.5 를 곱하면서 재시도를 하는것은 Retryer.Default 생성자에서 제공을 해주고 있지 않아, 이부분을 변경하고 싶다면 아래 2가지 중 하나를 해줘야 합니다.
            + 1.5 를 곱하는 로직은 `feign.Retryer.Default#nextMaxInterval` 여기에 있습니다.
            + RetryableException 에 재시도를 하는 시간을 retryAfter 에 전달하면 됩니다. 다만, Retryer 에 설정한 최대시간 보다는 적어야 합니다.<br/>
            최대시간보다 더 크다면, 최대시간으로 설정되어 재시도를 합니다.
                ```java
                public RetryableException(String message, Date retryAfter) {
                    super(message);
                    this.retryAfter = retryAfter != null ? retryAfter.getTime() : null;
                  }
                ```
            + feign.Retryer 를 상속하여 Retryer 를 구현하고 그걸 override 하도록 설정하면 됩니다.

### 추가로 설정하면 좋은 것
<hr/>

* 이 내용은 저희팀 [권남님의 블로그](http://kwonnam.pe.kr/wiki/java/jackson)를 참고해서 넣은 내용입니다.
* 이 2가지에 대해서 기본설정을 변경하는게 좋아요.
    - READ_UNKNOWN_ENUM_VALUES_AS_NULL 기본값(false)
    - FAIL_ON_UNKNOWN_PROPERTIES 기본값(true)
        + 이 값은 Jackson2 에서 명시적으로 설정을 하지 않았다면 기본값을 false 로 변경합니다.(Jackson2ObjectMapperBuilder#customizeDefaultFeatures)
        ```java
        @EnableFeignClients
        ...
        @Configuration
        public class ServiceConfig implements Jackson2ObjectMapperBuilderCustomizer {
            ...
            @Override
            public void customize(Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder) {
                jacksonObjectMapperBuilder
                    .featuresToEnable(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)
                    .featuresToDisable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
            }
        }
        ```

### 마지막으로
<hr/>

* Feign 을 사용하게 되면, RestTemplate 보다 Rest API 사용하는데 필요한 설정이 간편해집니다.
    - 이러한 편한점으로 인해 비지니스 로직에 더 집중을 할 수 있었습니다.
* 다른 라이브러리에 비하면, 학습의 어려움이 거의 없습니다.
    - 위에 적은 하기쉬운 실수를 참고하시면 큰 어려움 없이 도입을 하실 수 있습니다.

* 그래도 망설여지신다면 일단 한번 써보세요~(**JUST DO IT!!**)
    OkHttp has HTTP/2, a built-in response cache, web sockets, and a simpler API.
    It’s got better defaults and is easier to use efficiently.
    It’s got a better URL model, a better cookie model, a better headers model and a better call model. OkHttp makes canceling calls easy.
    OkHttp has carefully managed TLS defaults that are secure and widely compatible.
    Okhttp works with Retrofit, which is a brilliant API for REST.
    It also works with Okio, which is a great library for data streams.
    OkHttp is a small library with one small dependency (Okio) and is less code to learn.
    OkHttp is more widely deployed, with a billion Android 4.4+ devices using it internally.
    ```

### logging
* feign 의 logging 설정의 경우, `DEBUG` level 에서만 작동을 합니다. [feign logging](https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-feign.html#_feign_logging)

### error response 처리
* feign 의 경우 `200 <= response status < 300` 일때만 정상이라고 판단하고 (`decode404` 가 true 이면, 404 포함), 그 이외의 http status 값은 errorDecoder 가 수행이 됩니다.
* 그때는, method 의 return type 을 feign 의 Response 로 지정한다음에 errorDecoder 를 수행여부를 직접 코드로 구현하는 방법이 있습니다.
* sample 로 controller 를 하나를 받고, 메시지에는 fail 에 대한 값을 넣고 httpStatus 값은 받은 값을 리턴하게 했습니다.
    ``` java
    @RestController
    public class HelloController {
        // ...
        @GetMapping("/fail/{status}")
        public ResponseEntity<HelloResponse<String>> sample(@PathVariable("status") int status) {
            return new ResponseEntity<>(HelloResponse.of(4000, "It's fail", "this is messages"),
                    HttpStatus.valueOf(status));
        }
        // ...
    }
    ```
* response dto 는 대략적으로 이렇게 만들었습니다.
    ``` java
    public class HelloResponse<T> {
        private int status;
        private String message;
        private T data;
    }
    ```
* feign client 에서 method return type 을 feign 의 `feign.Response` 로 하고 있습니다.
    ``` java
    @FeignClient(name = "hello-client", url = "http://localhost:8080")
    public interface HelloClient {
        // ...
        @RequestLine("GET /fail/{status}")
        Response fail(@Param("status") int status);
        // ...
    }
    ```
* test code 에서 실제로 호출해보겠습니다.
    ``` java
    def "fail"() {
        expect:
        Response response = helloClient.fail(HttpStatus.UNAUTHORIZED.value())

        if (HttpStatus.Series.valueOf(response.status) == HttpStatus.Series.SERVER_ERROR) {
            throw new IllegalStateException("server error 발생");
        }

        System.out.println(response)
    }
    ```
    ``` java
    io.github.mayaul.basic.HelloClient       : [HelloClient#fail] ---> GET http://localhost:8080/fail/401 HTTP/1.1
    io.github.mayaul.basic.HelloClient       : [HelloClient#fail] header: header1
    io.github.mayaul.basic.HelloClient       : [HelloClient#fail] ---> END HTTP (0-byte body)
    io.github.mayaul.basic.HelloClient       : [HelloClient#fail] <--- HTTP/1.1 401 (33ms)
    io.github.mayaul.basic.HelloClient       : [HelloClient#fail] content-type: application/json;charset=UTF-8
    io.github.mayaul.basic.HelloClient       : [HelloClient#fail] date: Thu, 19 Dec 2019 01:17:35 GMT
    io.github.mayaul.basic.HelloClient       : [HelloClient#fail] transfer-encoding: chunked
    io.github.mayaul.basic.HelloClient       : [HelloClient#fail] 
    io.github.mayaul.basic.HelloClient       : [HelloClient#fail] {"status":4000,"message":"It's fail","data":"this is messages"}
    io.github.mayaul.basic.HelloClient       : [HelloClient#fail] <--- END HTTP (63-byte body)
    
    {"status":4000,"message":"It's fail","data":"this is messages"}
    ```

    - `feign.Response` 의 경우는 httpStatus code 값을 가지고 있는데, 이 값을 가지고 와서 특정 httpStatus code 에 대한 처리를 feign 의 기본동작과 달리 설정할 수 있습니다.

### feign configuration class 에서 `@Configuration` 넣어보기
* configuration class 에 `@Configuration` 을 하지 않으면 Bean 이 Singleton 이 되지 않는 것으로 알고 있습니다.
* feign 의 configuration class 의 경우 이전 게시글에서 @Configuration 을 넣지 않는것을 추천하였는데, feign guide 문서에는 이와 반대로 하고 있습니다.[참고링크](https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-feign.html#spring-cloud-feign-overriding-defaults)
    ```
    FooConfiguration does not need to be annotated with @Configuration. 
    However, if it is, then take care to exclude it from any @ComponentScan that would otherwise include this configuration as it will become the default source for feign.Decoder, feign.Encoder, feign.Contract, etc., when specified. 
    This can be avoided by putting it in a separate, non-overlapping package from any @ComponentScan or @SpringBootApplication, or it can be explicitly excluded in @ComponentScan.
    ```
* feign 용 configuration class 을 `@Configuration` 을 붙이고, `@SpringBootApplication` 또는 `@ComponentScan` 에서 탐색가능한 경로에 있다면 모든 feign 용 client 에 적용이 됩니다.
    - 예를 들어, Header 를 넣는 configuration 을 `@Configuration`을 넣는다면 모든 feign client 에 적용이 됩니다.
    ``` java
    @Configuration
    public class FeignHeader1Configuration {
        @Bean
        public RequestInterceptor requestInterceptor() throws InterruptedException {
            return requestTemplate -> requestTemplate.header("header", "header1");
        }
    }
    ```
    ``` java
    @FeignClient(value = "client", url = "${external-api.http-bin}")
    public interface Client {
        @RequestLine("GET /status/{status}")
        void status(@Param("status") int status);
    }
    @FeignClient(value = "client2", url = "${external-api.http-bin}", configuration = {FeignHeader1Configuration.class})
    public interface Client2 {로
        @RequestLine(value = "GET /status/{status}")
        void status(@Param("status") int status);
    }
    ```

    - `@FeignClient` 에 `FeignHeader1Configuration` 적용하지 않은 `Client` 에도 header 가 넣어져서 호출이 됩니다.

* 모든 feign client 에 적용이 되어야하는 설정은 `@Configuration` 으로 넣어서 자동으로 Bean 이 생성되어서 적용이 되게 하고, 그 이외 client 별로 적용이 되어야 하는건 `@FeignClient` 에 configuration attribute 로 설정합니다.
    - 같은 bean 설정이 있다면 `@FeignClient` configuration 설정으로 적용된것으 override 되어, 적용이 됩니다.


    ``` java
    @Configuration
    public class FeignHeader1Configuration {
        @Bean
        public RequestInterceptor requestInterceptor() throws InterruptedException {
            return requestTemplate -> requestTemplate.header("header", "header1");
        }
    }
    
    public class FeignHeader2Configuration {
        @Bean
        public RequestInterceptor requestInterceptor() throws InterruptedException {
            return requestTemplate -> requestTemplate.header("header", "header2");
        }
    }
    ```
    ``` java
    @FeignClient(value = "client2", url = "${external-api.http-bin}", configuration = {FeignHeader2Configuration.class})
    public interface Client2 {
        @RequestLine(value = "GET /status/{status}")
        void status(@Param("status") int status);
    }
    ```
    + client2 를 호출하면 FeignHeader1Configuration 에 있는 `header1` 아니라 `header2` 가 header 에 넣어져서 호출이 됩니다.
* feign client 에 동일한 configuration class 을 설정을 해도 bean 이 중복으로 생성이 됩니다.
    + 각 bean 을 설정을 하는곳에 log 을 찍어놓고 확인을 해보면, 동일한 configuration 이지만, 여러개의 feign client 에 적용을 한다면 적용된 client 만큼 bean 이 생성이 됩니다.
    + 모두 동일하게 적용이 되어야 하는 `Contract` 와 `LocalDate, LocalTime, LocalDateTime` 를 ISO format 으로 보내는 설정정도는 모든 client 에 적용이 될 만한 것으로 생각이 됩니다.
        - 이런 설정은, `@Configuration` annotation 을 붙여 `@ComponentScan`에 탐색이 되도록 하여, bean 을 1개만 만들고 모든 client 에 적용 시키는 방법이 좋을 것 같습니다.

### @Configuration 을 feign 용 configuration 에서 사용하기
* 위에서 설명을 했듯이 Feign용 configuration class 에 `@Configuration` 을 넣으면 원하지 않는 client 에 적용이 됩니다.
* 그래서, 별도의 annotation 을 만들고 `@ComponentScan` 에서 exclude 되도록 설정을 하는 것도 방법입니다.
    + 실수로 `@Configuraiton` annotation 을 붙일경우의 방어도 될 것 같습니다.

    + feign configuration 을 component scan 에서 ignore 처리를 위해서 마커용 annotation 을 생성합니다
    ``` java
    @Target({ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    public @interface FeignConfiguration { }
    ```
    + application 에서 `@ComponentScan` 에 `ExcludeFilters` 를 설정합니다.
    ``` java
    @SpringBootApplication
    @EnableFeignClients
    @ComponentScan(basePackages = "io.github.mayaul", excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION, value = FeignConfiguration.class)})
    public class Application { }
    ```
    + feign 개별 client 용 configuration class 에 적용을 합니다.
    ``` java
    @Configuration
    @FeignConfiguration
    public class FeignHeader2Configuration {
        @Bean
        public RequestInterceptor requestInterceptor() throws InterruptedException {
            return requestTemplate -> requestTemplate.header("header", "header2");
        }
    }
    ```
    + 이렇게 하면 원하는 `@FeignClient` 에 configuration 에 `FeignHeader2Configuration` 넣은것만 적용되고, 다른 client 에는 영향을 주지 않게 됩니다.


### feign client 용 interface 만 정의하고 실제 구현체는 달리 사용하기
* feign 을 쓰다보면 1개 interface 로 2개 이상의 feign client 를 만들고 싶을때가 있습니다.
* 예를 들어 sms message 를 보내는 restful 서비스가 있고, retry 여부를 결정을 하고 싶을 때가 있습니다.
    + 
    ``` java
    interface MessageClient {
        @RequestLine("POST /sms")
        ResponseDto sendSms(@RequestBody RequestDto RequestDto);
    }
    ```
    + retry 하지 않는 client
    ``` java
    @FeignClient(name = "message-api", url = "${external.sms.url}")
    public interface MessageNoRetryClient extends MessageClient {  }
    ```
    + retry 하는 client
    ``` java
    @FeignClient(name = "message-api-retryable", url = "${external.sms.url}", configuration = {FeignRetryConfiguration.class})
    public interface MessageRetryClient extends MessageClient {  }
    ```
    이렇게 하면 같은 API 를 사용하면서 retry 를 하는 client 와 retry 를 하지 않는 client 를 만들 수 있습니다.<br/>
    > 일전에 이전 블로그에서 `connection 을 가지고 오지 못했다거나, httpStatus code 가 0 이하인 invalid 한 status code 값이어야 RetryableException 이 발생` 이 된다고 했으나<br/>
    > 기본적으로 `RetryableException` 발생이 된다고 해도, feign 에서 기본적으로 만드는 bean 은 `feign.Retryer#NEVER_RETRY` 입니다. <br/>
    > Retry 가 필요한경우 별도의 Configuration class 를 만들어 `feign.Retryer.Default` 를 생성해서 넣어주면 됩니다. <br/>
    > 생성자 parameter 로 재시도 주기와 최대재시도 횟수등을 정할 수 있으니 기본적이 재시도 동작을 설정 할 수 있습니다.<br/>
    > Retry 설정에 자세한 내용은 이전 내용을 참고해주세요[링크](http://woowabros.github.io/experience/2019/05/29/feign.html#%EC%A2%80%EB%8D%94-%EB%82%98%EC%95%84%EA%B0%80%EA%B8%B0)

### @RequestParam 에 Collection 이 들어갈때 key=value1&key=value2 가 아니라 key=value1,value2 하기
* 기존에 feign 에서 @RequestParam 에 collection 을 넣으면 `key=value1&key=value2` 이렇게 호출이 됩니다.
    - 이 내용은 이미 OpenFeign github 에 리포팅이 되어 있습니다.[링크](https://github.com/OpenFeign/feign/pull/543/commits/4beb8b005baaee5e0874ab2947ab0a6898485983)
* 결론적으로 OpenFeign 9.6.0 버전에는 fix 가 되어 있습니다.[링크](https://github.com/OpenFeign/feign/compare/release-9.6.0...master)
* 다만, 기존에 SpringContract 가 아닌 Feign 의 default contract 를 써야 가능합니다.
    - Spring 의 `@GetMapping, @PostMapping, @PutMapping, @DeleteMapping` 등은 Rest  호출을 받기 위해서 만들어진거지, 호출을 위한 목적이 아니니 이참에 feign 으로 바꾸는게 나을 것 같습니다.
* SpringBoot 2.1.x 버전에 맞는 SpringCloud 버전은 Greenwich 인데, 여기 버전에서는 OpenFeign 버전이 10.1.0 으로 변경되었습니다.
* SpringBoot 2.0.x 버전에 맞는 SpringCloud 버전은 Finchley 인데, Finchley.SR4 까지가 최신버전이고 Finchley.SR2 부터 반영되었습니다.
    > 여기서 SR 버전은[링크](https://spring.io/projects/spring-cloud#release-trains)
    ```
    if there is a critical bug in one of them that needs to be available to everyone, the release train will push out "service releases" with names ending ".SRX", where "X" is a number.
    ```
    > 최신버전을 사용을 하는것이 좋습니다.[MVN Repository](https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies)
* 이제 사용하는 방법에 대해서 알아보겠습니다.
    - 일단 `httpbin.org` 에는 array 를 받는것이 없어서, 제가 sample 로 controller 를 하나 만들었습니다.
    ``` java
    @RestController
    public class HelloController {
        // ...
        @GetMapping("/array")
        public ResponseEntity<List<String>> array(@RequestParam("values") List<String> values) {
            return new ResponseEntity<>(values, HttpStatus.OK);
        }
        
        // ...
    }
    ```
    ``` java
    @FeignClient(name = "hello-client", url = "http://localhost:8080")
    public interface HelloClient {
        // ...
        @RequestLine("GET /array?values={values}")
        List<String> array(@Param("values") List<String> values);
        // ...
    }
    ```
    기본적으로 이렇게 호출을하면 로그는 아래와 같습니다.
    ``` java
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] ---> GET http://localhost:8080/array?values=a&values=b&values=c HTTP/1.1
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] header: header1
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] ---> END HTTP (0-byte body)
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] <--- HTTP/1.1 200 (34ms)
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] content-type: application/json;charset=UTF-8
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] date: Thu, 19 Dec 2019 00:10:15 GMT
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] transfer-encoding: chunked
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] 
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] ["a","b","c"]
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] <--- END HTTP (13-byte body)
    ```
    ``` java
    @FeignClient(name = "hello-client", url = "http://localhost:8080")
    public interface HelloClient {
        // ...
        @RequestLine(value = "GET /array?values={values}", collectionFormat = CollectionFormat.CSV)
        List<String> array(@Param("values") List<String> values);
        // ...
    }
    ```
    와 같이 collectionFormat 을 지정할 수 있고, `CSV` 로 하면
    ``` java
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] ---> GET http://localhost:8080/array?values=a,b,c HTTP/1.1
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] header: header1
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] ---> END HTTP (0-byte body)
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] <--- HTTP/1.1 200 (15ms)
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] content-type: application/json;charset=UTF-8
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] date: Thu, 19 Dec 2019 00:14:34 GMT
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] transfer-encoding: chunked
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] 
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] ["a","b","c"]
    io.github.mayaul.basic.HelloClient       : [HelloClient#array] <--- END HTTP (13-byte body)
    ```
    이렇게 CSV 로 보내지는것을 볼 수 있습니다. 기본값은 처음에 보았던것처럼 펼쳐서 보내는 `EXPLODED` 입니다. <br/>

    | value | description |
    |:---------------|:-------|
    | EXPLODED | 구분자가 없고, 펼쳐서 보낸다.(default) |
    | CSV | `,` 를 구분자로 한다. |
    | SSV | `[space]`(빈문자열) 를 구분자로 한다. |
    | TSV | `[tab]`(탭) 를 구분자로 한다. |
    | PIPES | `|` 를 구분자로 한다. |
